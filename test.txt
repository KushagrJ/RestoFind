/*

 * Node.js is a runtime environment that allows you to run JavaScript code on
   the server (i.e. outside a web browser).
 * Express.js is a framework that works on top of Node.js.
   It provides various mechanisms to handle common server-side tasks.
 * EJS (Embedded JavaScript) is a templating language that lets you generate
   HTML with plain JavaScript.
 * Mongoose.js is an Object-Document Mapper library which allows you to interact
   with MongoDB (which is a document database) using JavaScript objects.

 * Middleware in Express are functions that come into play after the server
   receives the request and before the response is sent to the client.
 * They are arranged in a chain and are called in sequence.

 * From within a folder, use npm init to create a package.json file for the
   corresponding Node.js web application.
 * npm init -y will create the package.json file using the default settings.

 * Use sudo npm i express mongoose ejs method-override etc. to install Express,
   Mongoose, EJS, method-override, etc. for the corresponding Node.js project.

 * Use node app.js or nodemon app.js to start the Express server.
   Using nodemon will automatically restart the server whenever changes are
   saved.

 * Go to http://localhost:<port number> (for eg., localhost:3000) using a web
   browser to see the first page hosted from the corresponding web application.

 * Use sudo brew services start mongodb-community@<version no. (for eg.. 6.0)>
   to start the MongoDB service.
 * To access the MongoDB shell, use mongosh (instead of mongo).

 * The asyncHandler() described at https://stackoverflow.com/a/51391081 has not
   been used here because understanding it requires a good knowledge of
   JavaScript.

 * To understand cookies and sessions, see https://stackoverflow.com/a/32564053,
   MDN, freeCodeCamp, Google, etc.

 * const hashed_password = await bcrypt.hash(password, 12);
   Here, 12 represents the cost factor, which controls how much time is needed
   to calculate a single BCrypt hash. The higher the cost factor, the more
   hashing rounds are done. Increasing the cost factor by 1 doubles the
   necessary time. The more time is necessary, the more difficult is
   brute-forcing.
 * The hashed password consists of the salt in plain text, concatenated with the
   hashed version of the salt + the password.
   For eg., if the salt is nOUIs5kJ7naTuTFkBy1veu and if the password is abcdef,
   then the resulting hashed password may be
   $2y$12$nOUIs5kJ7naTuTFkBy1veuK0kSxUFXfuaOKdOKf9xYT0KKIGSJwFa, where 2y
   represents the hashing algorithm (BCrypt), 12 is the cost factor,
   nOUIs5kJ7naTuTFkBy1veu is the salt, and K0kSxUFXfuaOKdOKf9xYT0KKIGSJwFa is
   the hashed version of the salt + abcdef.
 * if (!(req.session.user_id)) {
       // This code will be reached, for eg., when user_id is undefined (such
       // as when the user_id property doesn't exist on the req.session object
       // because no successful login has been done with respect to the current
       // session), or when user_id is equal to null (such as when user_id is
       // explicitly assigned null during logging out the user with respect to
       // the current session).
   }
 * Instead of implementing authentication from scratch (by using brycpt, by
   manually manipulating the req.session object, etc. (as shown above)), we have
   used Passport.js, which does all of this work for us.

 * To understand Bootstrap, EJS, Node.js, Express.js, MongoDB, Mongoose.js,
   Passport.js, etc., see MDN, freeCodeCamp, documentations, Google, etc.

 */







IMPORTANT POINTS -
01. NO VALIDATIONS HAVE BEEN IMPLEMENTED TO ENSURE THAT REQUESTS VIA, FOR EG.,
    POSTMAN ARE VALID.
02, CONCURRENCY HASN'T BEEN CONSIDERED, AND THE APP HAS BEEN BUILT ASSUMING THAT
    ONLY ONE PERSON WILL BE USING IT AT ANY GIVEN TIME.
03. HERE, VOTE IS ITS OWN MODEL, WHEREAS CANDIDATE ISN'T (AND IS DIRECTLY
    EMBEDDED INSIDE POLL).
    ACTUALLY, BOTH ARE SIMILAR AND BOTH COULD'VE BEEN THEIR OWN MODELS, OR BOTH
    COULD'VE BEEN DIRECTLY EMBEDDED INSIDE POLL.
04. IN THE ER DIAGRAM, MAKE 4 ENTITIES - POLL, USER (IS-A VOTER/ORGANISER),
    CANDIDATE, VOTE.
05. AFTER AN EDIT, THE VOTES CORRESPONDING TO THOSE CANDIDATES WHICH HAVE BEEN
    DELETED AUTOMATICALLY GET DELETED.
    SIMILARLY, AFTER AN EDIT, ONLY THOSE VOTES REMAIN WHICH HAVE BEEN MADE BY
    THE CURRENTLY ELIGIBLE VOTERS, AND ALL OTHER VOTES AUTOMATICALLY GET
    DELETED.
06. A CANDIDATE CAN ONLY BE DELETED BY SELECTING THE DELETE? CHECKBOX.
    CHANGING THE TITLE, DESCRIPTION OR IMAGES, BUT NOT SELECTING THE DELETE?
    CHECKBOX, DOESN'T REPLACE THE CANDIDATE, AS THE CORRESPONDING VOTES OF THAT
    CANDIDATE STILL REMAIN.
    SIMILARLY, IF THE DELETE? CHECKBOX HAS BEEN SELECTED, THEN THAT CANDIDATE
    GETS DELETED EVEN IF THE TITLE, DESCRIPTION OR IMAGES HAVE BEEN CHANGED.
07. ON BOTH THE NEW PAGE AND THE EDIT PAGE, IT MUST BE ENSURED THAT AT LEAST 2
    CANDIDATES ARE ADDED, AND IF ANYONE_CAN_VOTE IS FALSE, THEN AT LEAST 1 VOTER
    IS ADDED.
    ALSO, IT MUST BE ENSURED THAT EMPTY/DUPLICATE VOTERS AREN'T ADDED.
08. AFTER AN EDIT, IF MULTIPLE_VOTES_ALLOWED IS CHANGED, THEN ALL EXISTING VOTES
    AUTOMATICALLY GET DELETED.
    SIMILARLY, AFTER AN EDIT, IF ORGANISER_CAN_VOTE IS CHANGED TO FALSE, THEN
    THE ORGANISER'S VOTES (IF ANY) AUTOMATICALLY GET DELETED.







Show Page


Poll Details              Candidates                   Results

Eligible Voters           Cast Vote                    Votes


Done
Poll Details
(1, 2, 3, 4)

Done
Eligible Voters
(1, 2 - Determined by e)

Done
Candidates
(1, 2, 3)

Testing Ongoing
[
    1. WHEN A CANDIDATE IS DELETED, EVEN THOSE VOTES OF OTHER CANDIDATES GET
       DELETED AS WELL. FIX THIS.
    2. WHEN A VOTER IS DELETED, EVEN THOSE VOTES BY OTHER VOTERS GET DELETED AS
       WELL. FIX THIS.
    3. ETC.
]
Cast Vote
(1, 3) (Select/Radio - Determined by a)

Results
(1, 2, 3 - Determined by c)

Votes
(1, 2, 3 - Determined by c and d)


THOROUGH TESTING TO BE DONE AFTER COMPLETING THE SHOW PAGE.


INSTEAD OF GIVING THE OPTION TO DELETE VOTES IN THE 'VOTES' SECTION, SIMPLY
CREATE A NEW CARD CONSISTING OF PAST VOTES AND GIVE AN OPTION TO DELETE OVER
THERE.
CONCLUDED POLLS SHOULD NOT HAVE THE DELETE VOTE BUTTONS.


Types of viewers of show page -
1. Organiser, Eligible Voter (determined by b)
2. Organiser, Non-Eligible Voter (determined by b)
3. Non-Organiser, Eligible Voter (determined by e and voters)
4. Non-Organiser, Non-Eligible Voter (determined by e and voters)
   (Those who aren't logged in are Non-Organiser, Non-Eligible Voters)

Conditions -
a. multiple_votes_allowed
b. organiser_can_vote
c. ongoing_poll_results_visible
d. anonymous_votes
e. anyone_can_vote

If ongoing poll results should not be visible, then Results and Votes must not
be visible, irrespective of anonymous votes.
Show a card saying that the results will be available after the poll concludes.

Show Eligible Voters and Votes as collapsible panels.







Index Page

Two columns -
1. Ongoing
2. Concluded







Not Required -
Also, on the edit page, if a candidate has been marked to be deleted, then its
title must no longer be required.
Add an event listener to add_poll_button which will dynamically remove the
required attribute from every corresponding candidate's title.
